{
  "language": "Solidity",
  "sources": {
    "contracts/BTC1USD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./interfaces/IBTC1USD.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\ncontract BTC1USD is ERC20, ERC20Permit, Ownable2Step, IBTC1USD {\n    address public vault;\n    address public weeklyDistribution;\n    bool public criticalParamsLocked;\n\n    // Timelock for critical address changes (2-day delay)\n    uint256 public constant TIMELOCK_DELAY = 2 days;\n\n    struct PendingChange {\n        address newAddress;\n        uint256 executeAfter;\n    }\n\n    PendingChange public pendingVaultChange;\n    PendingChange public pendingWeeklyDistributionChange;\n\n    modifier onlyVaultOrDistribution() {\n        require(\n            vault != address(0) && weeklyDistribution != address(0),\n            \"BTC1USD: not configured\"\n        );\n        require(\n            msg.sender == vault || msg.sender == weeklyDistribution,\n            \"BTC1USD: unauthorized\"\n        );\n        _;\n    }\n\n    modifier onlyOwnerUnlocked() {\n        require(!criticalParamsLocked, \"BTC1USD: params locked\");\n        _;\n    }\n    modifier onlyVault() {\n        require(msg.sender == vault, \"BTC1USD: only vault\");\n        _;\n    }\n\n    event VaultChanged(address indexed oldVault, address indexed newVault);\n    event WeeklyDistributionChanged(\n        address indexed oldDist,\n        address indexed newDist\n    );\n    event CriticalParamsLocked(address owner);\n\n    // Timelock events\n    event VaultChangeInitiated(\n        address indexed oldVault,\n        address indexed newVault,\n        uint256 executeAfter\n    );\n    event VaultChangeCancelled(address indexed cancelledVault);\n    event WeeklyDistributionChangeInitiated(\n        address indexed oldDist,\n        address indexed newDist,\n        uint256 executeAfter\n    );\n    event WeeklyDistributionChangeCancelled(address indexed cancelledDist);\n\n    constructor(\n        address initialOwner,\n        address _vault,\n        address _weeklyDistribution\n    ) ERC20(\"BTC1USD\", \"BTC1\") ERC20Permit(\"BTC1USD\") Ownable(initialOwner) {\n        vault = _vault;\n        weeklyDistribution = _weeklyDistribution;\n\n        if (_vault != address(0)) {\n            emit VaultChanged(address(0), _vault);\n        }\n        if (_weeklyDistribution != address(0)) {\n            emit WeeklyDistributionChanged(address(0), _weeklyDistribution);\n        }\n    }\n\n    function decimals() public pure override(ERC20, IBTC1USD) returns (uint8) {\n        return 8;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    INITIAL SETUP (DEPLOYMENT ONLY)\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set vault address (only works if current vault is zero)\n    /// @dev For initial deployment only. Use timelock functions for changes.\n    function setVault(address _vault) external onlyOwner onlyOwnerUnlocked {\n        require(_vault != address(0), \"zero vault\");\n        require(vault == address(0), \"vault already set - use timelock\");\n        vault = _vault;\n        emit VaultChanged(address(0), _vault);\n    }\n\n    /// @notice Set weekly distribution address (only works if current address is zero)\n    /// @dev For initial deployment only. Use timelock functions for changes.\n    function setWeeklyDistribution(\n        address _wd\n    ) external onlyOwner onlyOwnerUnlocked {\n        require(_wd != address(0), \"zero distribution\");\n        require(\n            weeklyDistribution == address(0),\n            \"distribution already set - use timelock\"\n        );\n        weeklyDistribution = _wd;\n        emit WeeklyDistributionChanged(address(0), _wd);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    TIMELOCK VAULT ADDRESS CHANGES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initiate vault address change (step 1 of 2)\n    function initiateVaultChange(\n        address newVault\n    ) external onlyOwner onlyOwnerUnlocked {\n        require(newVault != address(0), \"zero vault\");\n        require(newVault != vault, \"same vault\");\n        require(\n            pendingVaultChange.newAddress == address(0),\n            \"BTC1USD: vault change pending\"\n        );\n\n        pendingVaultChange = PendingChange({\n            newAddress: newVault,\n            executeAfter: block.timestamp + TIMELOCK_DELAY\n        });\n\n        emit VaultChangeInitiated(\n            vault,\n            newVault,\n            pendingVaultChange.executeAfter\n        );\n    }\n\n    /// @notice Execute vault address change after timelock (step 2 of 2)\n    function executeVaultChange() external onlyOwner onlyOwnerUnlocked {\n        require(pendingVaultChange.newAddress != address(0), \"no pending\");\n        require(block.timestamp >= pendingVaultChange.executeAfter, \"timelock\");\n        address oldVault = vault;\n        vault = pendingVaultChange.newAddress;\n\n        delete pendingVaultChange;\n\n        emit VaultChanged(oldVault, vault);\n    }\n\n    /// @notice Cancel pending vault address change\n    function cancelVaultChange() external onlyOwner onlyOwnerUnlocked {\n        require(\n            pendingVaultChange.newAddress != address(0),\n            \"no pending change\"\n        );\n\n        address cancelled = pendingVaultChange.newAddress;\n        delete pendingVaultChange;\n\n        emit VaultChangeCancelled(cancelled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                TIMELOCK WEEKLY DISTRIBUTION CHANGES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initiate weekly distribution address change (step 1 of 2)\n    function initiateWeeklyDistributionChange(\n        address newDist\n    ) external onlyOwner onlyOwnerUnlocked {\n        require(newDist != address(0), \"zero distribution\");\n        require(newDist != weeklyDistribution, \"same distribution\");\n        require(\n            pendingWeeklyDistributionChange.newAddress == address(0),\n            \"BTC1USD: weekly dist change pending\"\n        );\n\n        pendingWeeklyDistributionChange = PendingChange({\n            newAddress: newDist,\n            executeAfter: block.timestamp + TIMELOCK_DELAY\n        });\n\n        emit WeeklyDistributionChangeInitiated(\n            weeklyDistribution,\n            newDist,\n            pendingWeeklyDistributionChange.executeAfter\n        );\n    }\n\n    /// @notice Execute weekly distribution address change after timelock (step 2 of 2)\n    function executeWeeklyDistributionChange()\n        external\n        onlyOwner\n        onlyOwnerUnlocked\n    {\n        require(\n            pendingWeeklyDistributionChange.newAddress != address(0),\n            \"no pending change\"\n        );\n        require(\n            block.timestamp >= pendingWeeklyDistributionChange.executeAfter,\n            \"timelock not expired\"\n        );\n\n        address oldDist = weeklyDistribution;\n        weeklyDistribution = pendingWeeklyDistributionChange.newAddress;\n\n        delete pendingWeeklyDistributionChange;\n\n        emit WeeklyDistributionChanged(oldDist, weeklyDistribution);\n    }\n\n    /// @notice Cancel pending weekly distribution address change\n    function cancelWeeklyDistributionChange() external onlyOwner onlyOwnerUnlocked {\n        require(\n            pendingWeeklyDistributionChange.newAddress != address(0),\n            \"no pending change\"\n        );\n\n        address cancelled = pendingWeeklyDistributionChange.newAddress;\n        delete pendingWeeklyDistributionChange;\n\n        emit WeeklyDistributionChangeCancelled(cancelled);\n    }\n\n    function lockCriticalParams() external onlyOwner {\n        require(!criticalParamsLocked, \"BTC1USD: already locked\");\n        require(vault != address(0), \"BTC1USD: vault not set\");\n        require(\n            weeklyDistribution != address(0),\n            \"BTC1USD: weekly dist not set\"\n        );\n\n        // Clear any pending changes to prevent bypass\n        delete pendingVaultChange;\n        delete pendingWeeklyDistributionChange;\n\n        criticalParamsLocked = true;\n        emit CriticalParamsLocked(owner());\n    }\n\n    function mint(\n        address to,\n        uint256 amount\n    ) external override onlyVaultOrDistribution {\n        _mint(to, amount);\n    }\n\n    function burnFrom(\n        address from,\n        uint256 amount\n    ) external override onlyVault {\n        _spendAllowance(from, msg.sender, amount);\n        _burn(from, amount);\n    }\n\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/interfaces/IBTC1USD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBTC1USD is IERC20 {\n    // State variables (view functions)\n    function vault() external view returns (address);\n    function weeklyDistribution() external view returns (address);\n    function criticalParamsLocked() external view returns (bool);\n    function decimals() external pure returns (uint8);\n    \n    // Admin functions (note: vault and weeklyDistribution are set via constructor)\n    // Changes to vault/weeklyDistribution require 2-day timelock via initiate/execute functions\n    function lockCriticalParams() external;\n    \n    // Minting and burning\n    function mint(address to, uint256 amount) external;\n    function burnFrom(address from, uint256 amount) external;\n    \n    // Note: EIP-2612 Permit functions (permit, nonces, DOMAIN_SEPARATOR) \n    // are inherited from ERC20Permit in the implementation\n    // They are not redeclared here to avoid conflicts\n    \n    // Note: Events are defined in the implementation contract\n    // to avoid redefinition errors\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "shanghai",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}
