// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./interfaces/IBTC1USD.sol";
import "./interfaces/IPriceOracle.sol";
import "./libraries/SafeMath.sol";
import "./libraries/FixedPoint8.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
// Legacy approve-based mint/redeem + Permit2 for gasless approvals
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "./interfaces/IPermit2.sol";

/**
 * @title VaultUpgradeable
 * @notice Upgradeable collateralized vault for BTC1USD minting and redemption
 *
 * SECURITY PROPERTIES:
 * - ✅ Standard ERC20 burn pattern (burnFrom with allowance)
 * - ✅ No forced burns - user must approve vault
 * - ✅ User approval required for redemption
 * - ✅ Oracle staleness protection
 * - ✅ Stress-mode redemption supported
 * - ✅ Upgrade-safe (initializer protected)
 */
contract VaultUpgradeable is Initializable, OwnableUpgradeable {
    using SafeMath for uint256;
    using FixedPoint8 for uint256;
    using SafeERC20 for IERC20;

    // ===== Constants (8-decimal fixed point) =====
    uint256 public constant MIN_COLLATERAL_RATIO        = 1.20e8; // 120%
    uint256 public constant MIN_COLLATERAL_RATIO_STABLE = 1.10e8; // 110%
    uint256 public constant STRESS_REDEMPTION_FACTOR    = 0.90e8; // 90%

    uint256 public constant DEV_FEE_MINT       = 0.01e8;  // 1%
    uint256 public constant DEV_FEE_REDEEM     = 0.001e8; // 0.1%
    uint256 public constant ENDOWMENT_FEE_MINT = 0.001e8; // 0.1%

    uint256 private constant DECIMALS = 1e8;

    // Permit2 contract (same address on all chains)
    address public constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;

    // ===== Core contracts =====
    IBTC1USD public btc1usd;
    IPriceOracle public priceOracle;

    // ===== Collateral management =====
    address[] public collateralTokens;
    mapping(address => bool) public supportedCollateral;
    mapping(address => uint256) public collateralBalances;

    // ===== Governance / state =====
    address public devWallet;
    address public endowmentWallet;
    bool public paused;

    uint256 public lastMintPrice;

    // ===== Events =====
    event Initialized(address indexed owner);
    event Mint(address indexed user, uint256 collateralIn, uint256 btc1Minted, address collateralToken);
    event Redeem(address indexed user, uint256 btc1Burned, uint256 collateralOut, address collateralToken);
    event MintPriceUpdated(uint256 newPrice);

    event CollateralAdded(address token);
    event CollateralRemoved(address token);
    event EmergencyPause();
    event EmergencyUnpause();

    modifier whenNotPaused() {
        require(!paused, "Vault: paused");
        _;
    }

    modifier validCollateral(address token) {
        require(supportedCollateral[token], "Vault: unsupported collateral");
        _;
    }

    // ===== Initializer (replaces constructor) =====
    function initialize(
        address initialOwner,
        address _btc1usd,
        address _priceOracle,
        address _devWallet,
        address _endowmentWallet
    ) external initializer {
        require(initialOwner != address(0), "Vault: owner zero");
        require(_btc1usd != address(0), "Vault: btc1usd zero");
        require(_priceOracle != address(0), "Vault: oracle zero");
        require(_devWallet != address(0), "Vault: dev zero");
        require(_endowmentWallet != address(0), "Vault: endowment zero");

        __Ownable_init(initialOwner);
        btc1usd = IBTC1USD(_btc1usd);
        priceOracle = IPriceOracle(_priceOracle);
        devWallet = _devWallet;
        endowmentWallet = _endowmentWallet;

        lastMintPrice = MIN_COLLATERAL_RATIO;
        emit Initialized(initialOwner);
        emit MintPriceUpdated(lastMintPrice);
    }

    // ===== Admin controls =====
    function addCollateral(address token) external onlyOwner {
        require(!supportedCollateral[token], "Vault: already supported");
        supportedCollateral[token] = true;
        collateralTokens.push(token);
        emit CollateralAdded(token);
    }

    function removeCollateral(address token) external onlyOwner {
        require(supportedCollateral[token], "Vault: not supported");
        require(collateralBalances[token] == 0, "Vault: collateral in use");

        supportedCollateral[token] = false;
        for (uint i = 0; i < collateralTokens.length; i++) {
            if (collateralTokens[i] == token) {
                collateralTokens[i] = collateralTokens[collateralTokens.length - 1];
                collateralTokens.pop();
                break;
            }
        }
        emit CollateralRemoved(token);
    }

    function emergencyPause() external onlyOwner {
        paused = true;
        emit EmergencyPause();
    }

    function emergencyUnpause() external onlyOwner {
        paused = false;
        emit EmergencyUnpause();
    }


    // ===== Views =====
    function getTotalCollateralValue() public view returns (uint256 totalValue) {
        for (uint i = 0; i < collateralTokens.length; i++) {
            address token = collateralTokens[i];
            uint256 bal = collateralBalances[token];
            if (bal == 0) continue;

            uint256 price = priceOracle.getPrice(token);
            uint8 decimals = IERC20Metadata(token).decimals();
            totalValue = totalValue.add(bal.mul(price).div(10 ** decimals));
        }
    }

    function getCollateralRatio() public view returns (uint256) {
        uint256 supply = btc1usd.totalSupply();
        if (supply == 0) return MIN_COLLATERAL_RATIO;
        return getTotalCollateralValue().multiply(DECIMALS).divide(supply);
    }

    // ===== Mint =====
    function mint(address collateralToken, uint256 depositAmount)
        external
        whenNotPaused
        validCollateral(collateralToken)
    {
        require(depositAmount > 0, "Vault: zero deposit");
        require(!priceOracle.isStale(), "Vault: oracle stale");

        _mintInternal(msg.sender, collateralToken, depositAmount);
    }

    // Mint with Permit2 (for tokens without native EIP-2612 support)
    function mintWithPermit2(
        address collateralToken,
        uint256 depositAmount,
        IPermit2.PermitTransferFrom calldata permit,
        bytes calldata signature
    ) external whenNotPaused validCollateral(collateralToken) {
        require(depositAmount > 0, "Vault: zero deposit");
        require(!priceOracle.isStale(), "Vault: oracle stale");
        require(permit.permitted.token == collateralToken, "Vault: token mismatch");
        require(permit.permitted.amount >= depositAmount, "Vault: insufficient permit amount");
        require(permit.deadline >= block.timestamp, "Vault: permit expired");

        // Use Permit2 SignatureTransfer - transfers tokens directly using the signature
        IPermit2(PERMIT2).permitTransferFrom(
            permit,
            IPermit2.SignatureTransferDetails({
                to: address(this),
                requestedAmount: depositAmount
            }),
            msg.sender,
            signature
        );

        // Update collateral balance and mint
        collateralBalances[collateralToken] = collateralBalances[collateralToken].add(depositAmount);
        _mintInternalAfterTransfer(msg.sender, collateralToken, depositAmount);
    }

    function _mintInternal(
        address user,
        address collateralToken,
        uint256 depositAmount
    ) internal {

        uint256 prevUSD = getTotalCollateralValue();
        uint256 prevSupply = btc1usd.totalSupply();
        uint256 mintPrice =
            prevSupply == 0
                ? MIN_COLLATERAL_RATIO
                : prevUSD.multiply(DECIMALS).divide(prevSupply);

        IERC20(collateralToken).safeTransferFrom(
            user,
            address(this),
            depositAmount
        );

        collateralBalances[collateralToken] =
            collateralBalances[collateralToken].add(depositAmount);

        uint256 usdValue = depositAmount
            .mul(priceOracle.getPrice(collateralToken))
            .div(10 ** IERC20Metadata(collateralToken).decimals());

        uint256 tokensToMint = usdValue.multiply(DECIMALS).divide(mintPrice);

        uint256 devFee = tokensToMint.multiply(DEV_FEE_MINT).divide(DECIMALS);
        uint256 endFee = tokensToMint.multiply(ENDOWMENT_FEE_MINT).divide(DECIMALS);

        btc1usd.mint(user, tokensToMint);
        if (devFee > 0) btc1usd.mint(devWallet, devFee);
        if (endFee > 0) btc1usd.mint(endowmentWallet, endFee);

        emit Mint(user, depositAmount, tokensToMint, collateralToken);

        lastMintPrice =
            getTotalCollateralValue().multiply(DECIMALS).divide(btc1usd.totalSupply());
        emit MintPriceUpdated(lastMintPrice);
    }

    /**
     * @notice Internal mint logic after transfer has already occurred (for Permit2)
     * @dev Used by mintWithPermit2 where Permit2 handles the transfer
     */
    function _mintInternalAfterTransfer(
        address user,
        address collateralToken,
        uint256 depositAmount
    ) internal {
        uint256 prevUSD = getTotalCollateralValue();
        uint256 prevSupply = btc1usd.totalSupply();
        uint256 mintPrice = prevSupply == 0
            ? MIN_COLLATERAL_RATIO
            : prevUSD.multiply(DECIMALS).divide(prevSupply);

        uint256 usdValue = depositAmount
            .mul(priceOracle.getPrice(collateralToken))
            .div(10 ** IERC20Metadata(collateralToken).decimals());

        uint256 tokensToMint = usdValue.multiply(DECIMALS).divide(mintPrice);

        uint256 devFee = tokensToMint.multiply(DEV_FEE_MINT).divide(DECIMALS);
        uint256 endFee = tokensToMint.multiply(ENDOWMENT_FEE_MINT).divide(DECIMALS);

        btc1usd.mint(user, tokensToMint);
        if (devFee > 0) btc1usd.mint(devWallet, devFee);
        if (endFee > 0) btc1usd.mint(endowmentWallet, endFee);

        emit Mint(user, depositAmount, tokensToMint, collateralToken);

        lastMintPrice = getTotalCollateralValue().multiply(DECIMALS).divide(btc1usd.totalSupply());
        emit MintPriceUpdated(lastMintPrice);
    }

    // ===== Redeem (FULL & SAFE) =====
    function redeem(uint256 tokenAmount, address collateralToken)
        external
        whenNotPaused
        validCollateral(collateralToken)
    {
        require(tokenAmount > 0, "Vault: zero amount");
        require(!priceOracle.isStale(), "Vault: oracle stale");

        _redeemInternal(msg.sender, tokenAmount, collateralToken);
    }

    // Redeem with Permit2 (gasless approval via Permit2)
    function redeemWithPermit2(
        uint256 tokenAmount,
        address collateralToken,
        IPermit2.PermitTransferFrom calldata permit,
        bytes calldata signature
    ) external whenNotPaused validCollateral(collateralToken) {
        require(tokenAmount > 0, "Vault: zero amount");
        require(!priceOracle.isStale(), "Vault: oracle stale");
        require(permit.permitted.token == address(btc1usd), "Vault: token must be BTC1USD");
        require(permit.permitted.amount >= tokenAmount, "Vault: insufficient permit amount");
        require(permit.deadline >= block.timestamp, "Vault: permit expired");

        // Use Permit2 SignatureTransfer to get BTC1USD from user
        IPermit2(PERMIT2).permitTransferFrom(
            permit,
            IPermit2.SignatureTransferDetails({
                to: address(this),
                requestedAmount: tokenAmount
            }),
            msg.sender,
            signature
        );

        // Burn the BTC1USD we received
        btc1usd.burn(tokenAmount);

        _redeemInternalAfterBurn(msg.sender, tokenAmount, collateralToken);
    }

    function _redeemInternal(
        address user,
        uint256 tokenAmount,
        address collateralToken
    ) internal {

        uint256 prevUSD = getTotalCollateralValue();
        uint256 prevSupply = btc1usd.totalSupply();
        uint256 cr =
            prevSupply == 0
                ? MIN_COLLATERAL_RATIO
                : prevUSD.multiply(DECIMALS).divide(prevSupply);

        uint256 price = priceOracle.getPrice(collateralToken);
        uint8 decimals = IERC20Metadata(collateralToken).decimals();

        uint256 collateralOut;

        if (cr >= MIN_COLLATERAL_RATIO_STABLE) {
            collateralOut = tokenAmount.mul(10 ** decimals).div(price);
        } else {
            uint256 stressedUSD =
                tokenAmount.multiply(cr).multiply(STRESS_REDEMPTION_FACTOR).divide(DECIMALS);
            collateralOut = stressedUSD.mul(10 ** decimals).div(price);
        }

        uint256 devFee =
            collateralOut.multiply(DEV_FEE_REDEEM).divide(DECIMALS);
        uint256 sendAmount = collateralOut.sub(devFee);

        require(
            collateralBalances[collateralToken] >= collateralOut,
            "Vault: insufficient collateral"
        );

        // Ensure redemption doesn't violate collateral ratio constraints
        uint256 usdRedeemed = collateralOut.mul(price).div(10 ** decimals);
        uint256 newUSD = prevUSD.sub(usdRedeemed);
        uint256 newSupply = prevSupply.sub(tokenAmount);
        
        if (newSupply > 0) {
            // Ensure new collateral ratio >= MIN_COLLATERAL_RATIO
            uint256 newCR = newUSD.multiply(DECIMALS).divide(newSupply);
            require(newCR >= MIN_COLLATERAL_RATIO, "Vault: redemption would break min CR");
        } else {
            // CRITICAL: If redeeming all tokens (supply -> 0), enforce CR = 120%
            // This means: remaining collateral value must equal 0 (all withdrawn)
            // OR if any collateral remains, it must satisfy: collateralUSD = 120% of 0 = 0
            require(newUSD == 0, "Vault: supply=0 requires collateral=0 (CR would be undefined)");
        }

        // Burn using standard burnFrom (user must have approved vault)
        btc1usd.burnFrom(user, tokenAmount);

        collateralBalances[collateralToken] =
            collateralBalances[collateralToken].sub(collateralOut);

        IERC20(collateralToken).safeTransfer(user, sendAmount);
        if (devFee > 0) IERC20(collateralToken).safeTransfer(devWallet, devFee);

        emit Redeem(user, tokenAmount, sendAmount, collateralToken);

        // Post-redemption invariant check: if supply is 0, collateral must be 0
        uint256 finalSupply = btc1usd.totalSupply();
        if (finalSupply == 0) {
            uint256 finalCollateral = getTotalCollateralValue();
            require(finalCollateral == 0, "Vault: INVARIANT VIOLATED - supply=0 but collateral>0");
        }
    }

    /**
     * @notice Internal redeem logic after burn has already occurred (for Permit2)
     * @dev Used by redeemWithPermit2 where tokens are transferred then burned
     */
    function _redeemInternalAfterBurn(
        address user,
        uint256 tokenAmount,
        address collateralToken
    ) internal {
        uint256 prevUSD = getTotalCollateralValue();
        uint256 prevSupply = btc1usd.totalSupply().add(tokenAmount); // Add back burned amount for calculation
        uint256 cr = prevSupply == 0
            ? MIN_COLLATERAL_RATIO
            : prevUSD.multiply(DECIMALS).divide(prevSupply);

        uint256 price = priceOracle.getPrice(collateralToken);
        uint8 decimals = IERC20Metadata(collateralToken).decimals();

        uint256 collateralOut;
        if (cr >= MIN_COLLATERAL_RATIO_STABLE) {
            collateralOut = tokenAmount.mul(10 ** decimals).div(price);
        } else {
            uint256 stressedUSD = tokenAmount.multiply(cr).multiply(STRESS_REDEMPTION_FACTOR).divide(DECIMALS);
            collateralOut = stressedUSD.mul(10 ** decimals).div(price);
        }

        uint256 devFee = collateralOut.multiply(DEV_FEE_REDEEM).divide(DECIMALS);
        uint256 sendAmount = collateralOut.sub(devFee);

        require(collateralBalances[collateralToken] >= collateralOut, "Vault: insufficient collateral");

        // Ensure redemption doesn't violate constraints
        uint256 usdRedeemed = collateralOut.mul(price).div(10 ** decimals);
        uint256 newUSD = prevUSD.sub(usdRedeemed);
        uint256 newSupply = btc1usd.totalSupply(); // Already burned

        if (newSupply > 0) {
            uint256 newCR = newUSD.multiply(DECIMALS).divide(newSupply);
            require(newCR >= MIN_COLLATERAL_RATIO, "Vault: redemption would break min CR");
        } else {
            require(newUSD == 0, "Vault: supply=0 requires collateral=0");
        }

        collateralBalances[collateralToken] = collateralBalances[collateralToken].sub(collateralOut);

        IERC20(collateralToken).safeTransfer(user, sendAmount);
        if (devFee > 0) IERC20(collateralToken).safeTransfer(devWallet, devFee);

        emit Redeem(user, tokenAmount, sendAmount, collateralToken);

        // Post-redemption invariant check
        if (btc1usd.totalSupply() == 0) {
            require(getTotalCollateralValue() == 0, "Vault: INVARIANT VIOLATED - supply=0 but collateral>0");
        }
    }
}
